/* File: Simulation.java
 * Author: Abhiyush Mittal (axm159230@utdallas.edu)
 */

import java.io.*;
import java.util.*;

/* Main class for executing the simulation */
public class Simulation {
	public static void Evaluate_Theoretical_Values(double _mu, int n, double dataset)
	{
		int m = 2;
		//service rate of the worker
		double mu = _mu;
		double lambda = dataset * m * mu;   /*arrival rate of the components 
		                                      generated by first machine*/
		double gamma = 5;       /*arrival rate of the components 
		                          generated by second machine */
		double rate = lambda + gamma;
		double p0 = 1,p1 = 0,p2 = 0,p3 = 0,p4 = 0;
		double EN = 0.0,ET = 0.0;
		double util = 0.0,block_prob = 0.0;  /* util = total utilization of the system
		                                        block_prob = blocking probability */
		double p,q,r,s;
		
		p = (rate/mu)*p0;
		q = (rate*rate*p0)/(2*mu*mu);
		r = (rate*rate*lambda*p0)/(mu*2*mu*2*mu);
		s = (rate*rate*lambda*lambda*p0)/(mu*2*mu*2*mu*2*mu);
		
		p0 = 1/(1 + (p/p0) + (q/p0) + (r/p0) + (s/p0));
		
		p1 = p*p0;
		p2 = q*p0;
		p3 = r*p0;
		p4 = s*p0;
		
		System.out.println("THEORETICAL VALUES");
		System.out.println("------------------");
		System.out.println("p0 = "+p0);
		System.out.println("p1 = "+p1);
		System.out.println("p2 = "+p2);
		System.out.println("p3 = "+p3);
		System.out.println("p4 = "+p4);
		
		
		EN = ((1*p1) + (2*p2) + (3*p3) + (4*p4));
		
		double lambda_eff;
		
		lambda_eff = ((rate * p0) + (rate * p1) + (lambda * p2) + (lambda * p3));
		
		ET = EN/lambda_eff;
		
		util = 1-p0-(0.5 * p1);
		
		block_prob = (lambda * p4)/((rate * p0) + (rate * p1) + (lambda * p2) + (lambda * p3 ) + (lambda * p4));

		
		System.out.println("The average number of components in the system = "+EN);
		System.out.println("The average time the components spend in the system = "+ET);
		System.out.println("Blocking Probability = "+block_prob);
		System.out.println("Utilization of the system = "+util);
	}
  

    public static void main(String[] args) {
        
    	EventQueue Elist;// Creating an event list for the events
        Elist = new EventQueue();
        System.out.print("Enter the number of datasets: ");
		Scanner sc = new Scanner(System.in);
		int num = sc.nextInt();
		double dataset[] = new double [num];
		System.out.println("Enter the value of datasets:");
		for(int i=0; i<num; i++)
		{
			dataset[i] = sc.nextDouble();
		}
		
        System.out.print("Enter the value of K: ");
        int K = sc.nextInt();
        System.out.print("Enter the value of mu: ");
        double mu = sc.nextDouble();
        int m = 2;
        //service rate by the worker             
        double pblock = 0.0,utilization = 0.0;
       
        double lambda = 0.0;//arrival rate of the first machine
        double gamma = 5;//arrival rate of the second machine
        final int ARR = 0;
        final int DEP = 1;
        final int ARR1 = 2;
        int numofComp = 0;//counter to keep track of the number of components that enter the system
          
        double clock = 0.0;             //System clock
        int N = 0;                      // Number of components in the system
        int Num_of_dep = 0;                   // Number of departures from system
        double EN = 0.0;                // For calculating E[N]
        double ET = 0.0;                // For calculating E[T]
        double Pblock = 0.0;
        boolean done = false;           // End condition satisfied?
      
        EventDetails currentEvent;
      
        double Rate = 0.0; 
        double Rate1 = gamma;
        RandomVar rv = new RandomVar();
        for(int j=0; j<num; j++) {
    	  lambda = dataset[j]*2*mu;
    	  Rate = lambda;            //Both machines generate components
        Elist.insert(rv.exponential_rv(Rate),ARR);//Generate first arrival event of lambda
        Elist.insert(rv.exponential_rv(Rate1),ARR1);//Generate second arrival event of gamma
      
        while(!done)
        {
            currentEvent = Elist.get();    //Get next event from list
            double prev = clock;    //Store old clock value
            clock = currentEvent.event_time;    //Update the system clock
          
            switch(currentEvent.event_type)
            {
            case ARR: 
            	EN += N*(clock-prev);                 //  update system statistics
                N++;                                    //  update system size
                numofComp++;                            //increment the counter
                Elist.insert(clock+rv.exponential_rv(Rate),ARR); //  generate next arrival
               if (N<=m) {                             // If number of components is less than or equal to m
                 Elist.insert(clock+rv.exponential_rv(mu),DEP);   //  generate its departure event
                 }
                
               if(N>=K && K>=2)
                {
                    pblock++;    //if N is going above K increment pblock                
                   
                }
               
               if ((N > 0) && (N < m)) 
               {//if N > 0 utilization is given by
                	utilization+= ((N/m)*(clock-prev));
                } 
                else if (N>=m){
                	utilization+= (clock-prev);
                }
                break;
            
            case DEP:                                    //if departure
                EN += N*(clock-prev);                 //  update system statistics
                N--;                                    //  decrement system size
                Num_of_dep++; 
                                                         //  increment number of departures
                 if (N>=2) {                            // If there are more customers
                    Elist.insert(clock+rv.exponential_rv(mu),DEP);   //  generate next departure
                    
                  }
                  if ((N>0)&&(N<m)) 
                  {
                  	utilization+= ((N/m)*(clock-prev));
                  	}
                  else if (N >= m){
                  	utilization+=(clock-prev);
                  	}
                  break;
                
            case ARR1:
            	//if arrival when rate is lambda
                EN+=N*(clock-prev);                        //update system statistics
                  
                N++;                                      // increment system size
                numofComp++;         
                if(N<2){
                Elist.insert(clock+rv.exponential_rv(Rate1),ARR1);//generating the next arrival of rate lambda
                  
                }
              
                if (N<=m) {                             // If this is the only customer
                  Elist.insert(clock+rv.exponential_rv(mu),DEP);   //  generate its departure event
                    }
                
                if ((N>0) && (N<m)) {
                	utilization+=((N/m)*(clock-prev));
                	} 	
                else if(N>=m)
                	
                	utilization +=(clock-prev);
                break;
                }
          
            currentEvent = null;
            if(Num_of_dep > 100000)
                done = true;//end condition
            }
        ET = (EN/Num_of_dep);
       
        Pblock = pblock/numofComp;
        System.out.println("\t\t================");
        System.out.println("\t\tFor dataset " + dataset[j]);
        System.out.println("\t\t================");
        Evaluate_Theoretical_Values(mu, num, dataset[j]);
        System.out.println("\nPRACTICAL VALUES");
        System.out.println("----------------");
        System.out.println("The average number of components in the system is = "+(EN/clock));
        System.out.println("The average time the components spend in the system is = "+ET);       
        System.out.println("The blocking probability of the system is = "+Pblock);
        System.out.println("The utilization of the system is = "+(utilization/clock));
        System.out.println("\n");
       }  
     }
}
